import { name } from '../../package.json';
import { generateRoutes } from './generate.js';
import {
  joinSegmentsName,
  routeQueryExtraName,
  routeQueryName,
  routeQueryParamName,
} from './helpers.macro.js' with { type: 'macro' };
import type { PathParameter, QueryParamConfig, Route, RoutesConfig } from './types.js';
import { baseUrlString, getInSourceHelpersModulePath, replacePathParams } from './utils';

export const getIndexCodeLines = (routes: Route[], config: RoutesConfig, moduleName: string) => [
  ...generateRoutes(
    routes,
    config,
    function* ({ identifier, key }) {
      yield `export { ${identifier}, ${identifier}_query } from './${moduleName}/${key}.js';`;
    },
    function* ({ identifier, key }) {
      yield `export { ${identifier} } from './${moduleName}/${key}.js';`;
    },
  ),
];

const helpersModule =
  process.env.NODE_ENV === 'production' ? `${name}/helpers` : getInSourceHelpersModulePath();

type RequiredImports = {
  base: boolean;
  helperNames: Set<string>;
};

export const getRouteKeyCodeLines = (routes: Route[], config: RoutesConfig) => {
  const requiredImports: RequiredImports = {
    base: false,
    helperNames: new Set(),
  };

  const body = [
    ...genBaseRoute(routes, config, requiredImports),
    ...routesCode(routes, config, requiredImports),
  ];

  const header: string[] = [];

  if (requiredImports.base) {
    header.push(`import { base } from '$app/paths';`);
  }

  if (requiredImports.helperNames.size > 0) {
    header.push(`import { ${[...requiredImports.helperNames].sort().join(', ')} } from '${helpersModule}';`);
  }

  if (header.length > 0) {
    header.push('');
  }

  return [
    `// This file is automatically generated by @fehnomenal/sveltekit-gen-routes.`,
    `// eslint-disable-next-line @typescript-eslint/ban-ts-comment`,
    `// @ts-nocheck`,
    '',
    ...header,
    ...body,
  ];
};

const genBaseRoute = (routes: Route[], config: RoutesConfig, requiredImports: RequiredImports) =>
  generateRoutes(
    routes,
    config,
    function* ({ baseUrl }) {
      yield* generateCodeForBaseRouteWithoutParams(baseUrl, requiredImports);

      return 'stop';
    },
    function* ({ baseUrl, pathParams, queryParams }) {
      yield* generateCodeForBaseRouteWithParams(baseUrl, pathParams, queryParams, requiredImports);

      return 'stop';
    },
  );

export function* generateCodeForBaseRouteWithoutParams(url: string, requiredImports?: RequiredImports) {
  requiredImports && (requiredImports.base = true);

  yield `const route = \`${baseUrlString('base', url)}\`;`;
}

export function* generateCodeForBaseRouteWithParams(
  url: string,
  pathParams: PathParameter[],
  queryParams: [string, QueryParamConfig][],
  requiredImports?: RequiredImports,
) {
  if (pathParams.length === 0) {
    yield* generateCodeForBaseRouteWithoutParams(url, requiredImports);
  } else {
    url = replacePathParams(url, pathParams, (param) => {
      if (!param.multi) {
        return `\${${param.name}}`;
      }

      // The rest param is the only parameter.
      let needSlashFallback = pathParams.length === 1;
      if (needSlashFallback) {
        const u = new URL(url, 'http://localhost');
        const segments = u.pathname.split('/').filter(Boolean);

        // And it is the last path segment.
        needSlashFallback = segments.indexOf(param.rawInRoute) === segments.length - 1;
      }

      requiredImports?.helperNames.add(joinSegmentsName());

      return `\${${joinSegmentsName()}(${param.name})${needSlashFallback ? ` || '/'` : ''}}`;
    });

    const parts = [`const route = (`];

    parts.push(pathParams.map((p) => p.name).join(', '));

    requiredImports && (requiredImports.base = true);

    parts.push(') => `');
    parts.push(baseUrlString('base', url));
    parts.push('`;');

    yield parts.join('');
  }
}

const routesCode = (routes: Route[], config: RoutesConfig, requiredImports: RequiredImports) =>
  generateRoutes(
    routes,
    config,
    function* ({ identifier, baseUrl, urlSuffix }) {
      yield* generateCodeForRouteWithoutParams(baseUrl, urlSuffix, identifier, requiredImports);
    },
    function* ({ identifier, baseUrl, urlSuffix, pathParams, queryParams }) {
      yield* generateCodeForRouteWithParams(
        baseUrl,
        urlSuffix,
        identifier,
        pathParams,
        queryParams,
        requiredImports,
      );
    },
  );

export function* generateCodeForRouteWithoutParams(
  baseUrl: string,
  urlSuffix: string | undefined,
  routeIdentifier: string,
  requiredImports?: RequiredImports,
) {
  let route = 'route';
  const url = baseUrl + (urlSuffix ?? '');

  if (urlSuffix) {
    route = `route_${routeIdentifier}`;

    yield `const ${route} = \`\${route}${urlSuffix}\`;`;
  }

  requiredImports?.helperNames.add(routeQueryName());

  yield `export const ${routeIdentifier} = ${route};`;
  yield `export const ${routeIdentifier}_query = ${buildRouteQuery(route, url)};`;
}

export function* generateCodeForRouteWithParams(
  baseUrl: string,
  urlSuffix: string | undefined,
  routeIdentifier: string,
  pathParams: PathParameter[],
  queryParams: [string, QueryParamConfig][],
  requiredImports?: RequiredImports,
) {
  let route: string;
  const url = baseUrl + (urlSuffix ?? '');

  if (pathParams.length === 0) {
    route = 'route';
  } else {
    route = `route(${pathParams.map((p) => p.name).join(', ')})`;
  }

  if (urlSuffix) {
    route = `\`\${${route}}${urlSuffix}\``;
  }

  const parts = [`export const ${routeIdentifier} = (`];

  const pathParamNames = pathParams.map((p) => p.name);
  const queryParamNames = queryParams.map(([name]) => name);
  const paramNames = [...pathParamNames, ...queryParamNames];

  if (pathParams.length + queryParams.length === 1) {
    const [paramName] = paramNames;
    parts.push(paramName!);
  } else {
    parts.push('{ ');
    parts.push(paramNames.join(', '));
    parts.push(' }');

    const anyRequired = !pathParams.every((p) => p.multi) || queryParams.some(([, p]) => p.required);

    if (!anyRequired) {
      parts.push(' = {}');
    }
  }

  parts.push(`, ${EXTRA_QUERY_PARAM_NAME}) => `);

  if (queryParams.length === 0) {
    requiredImports?.helperNames.add(routeQueryParamName());

    parts.push(buildRouteQueryParam(route, url));
  } else {
    requiredImports?.helperNames.add(routeQueryExtraName());

    parts.push(buildRouteQueryExtra(route, url, queryParamNames));
  }

  parts.push(';');

  yield parts.join('');
}

const EXTRA_QUERY_PARAM_NAME = 'q';

const buildRouteQuery = (route: string, url: string) =>
  routeCall(routeQueryName(), route, querySepCharArg(url));

const buildRouteQueryParam = (route: string, url: string) =>
  routeCall(routeQueryParamName(), route, EXTRA_QUERY_PARAM_NAME, querySepCharArg(url));

const buildRouteQueryExtra = (route: string, url: string, explicitQueryParamNames: string[]) =>
  routeCall(
    routeQueryExtraName(),
    route,
    EXTRA_QUERY_PARAM_NAME,
    `{ ${explicitQueryParamNames.join(', ')} }`,
    querySepCharArg(url),
  );

const routeCall = (fnName: string, url: string, ...args: (string | false | null | undefined)[]) =>
  `${fnName}(${[url, ...args.filter(Boolean)].join(', ')})`;

const querySepCharArg = (url: string) => (url.includes('?') ? `'&'` : undefined);
